# `Tab Here`, by Mark Vlach, October 2020## Duplicates the current browser selection path to a new tab in the browser's target (destination) window pane.#     If it's a folder or disk then make that the target path#     If it's a file then set the target path to the parent path of the file#     If there is no selection, set the target path to the path of the active browser window pane##use AppleScript version "2.4" # Yosemite (10.10) or lateruse scripting additionsset sourcePath to my getSourcePath()# create a new tab here at sourcePathactivate application "Path Finder"menu_click({"Path Finder", "File", "Tabs", "New Tab"})tell application "Path Finder" to select sourcePathreturn 0##################### handlers####################on getSourcePath()		local targetPath, theSelection, theCount, sel		tell application "Path Finder"		set theSelection to (selection)		set theCount to (count of selection)				# Default: set the targetPath to the path of the current browaer pane		set targetPath to the POSIX path of the (target of the front finder window)				# Loop through selections and set the targetPath to the first disk or folder found.		# If there are no selections or the selections are regular files,		# return the default targetPath of the current browser pane		if (theCount is greater than or equal to 1) then			repeat with sel in theSelection				if (class of sel) is disk or (class of sel) is fsFolder then					# we have a disk or folder selection so exit and return the selection path					set targetPath to POSIX path of (sel)					exit repeat				end if			end repeat			# else there are only files selected so exit and return the path of the			# current browser		end if						#	# If there is a single item selected, assume the user wants something close to that		#	if ((count of selection) is 1) then		#		set sourceCandidate to first item of selection		#					#		# If the user has selected a folder or disk icon, then make that the target folder		#		if (class of sourceCandidate) is disk or (class of sourceCandidate) is fsFolder then		#			set thePath to POSIX path of (sourceCandidate)		#		else		#			# If the user has selected anything else, then make the containing folder the selection		#			set thePath to POSIX path of (container of sourceCandidate)		#		end if		#					#	end if		#				#	# Otherwise, resort to the folder corresponding to the front-most window		#	if (thePath is equal to "") then		#		try		#			set thePath to the POSIX path of the target of the front finder window		#		on error		#			set thePath to ""		#		end try		#	end if		#				#	# If we still have nothing, assume the users home directory		#	if (thePath is equal to "") then		#		# set sourcePath to (path of home)		#		set thePath to POSIX path of home		#	end if		#end tell	end tell		return targetPathend getSourcePath## handlers for executing Path Finder menu commands## `menu_click`, by Jacob Rus, September 2006## Accepts a list of form: `{"Finder", "View", "Arrange By", "Date"}`# Execute the specified menu item.  In this case, assuming the Finder# is the active application, arranging the frontmost folder by date.#on menu_click(mList)	local appName, topMenu, r		# Validate our input	if mList's length < 3 then error "Menu list is not long enough"		# Set these variables for clarity and brevity later on	set {appName, topMenu} to (items 1 through 2 of mList)	set r to (items 3 through (mList's length) of mList)		# This overly-long line calls the menu_recurse function with	# two arguments: r, and a reference to the top-level menu	tell application "System Events" to my menu_click_recurse(r, ((process appName)'s Â¬		(menu bar 1)'s (menu bar item topMenu)'s (menu topMenu)))end menu_clickon menu_click_recurse(mList, parentObject)	local f, r		# `f` = first item, `r` = rest of items	set f to item 1 of mList	if mList's length > 1 then		set r to (items 2 through (mList's length) of mList)	end if		# either actually click the menu item, or recurse again	tell application "System Events"		if mList's length is 1 then			click parentObject's menu item f		else			my menu_click_recurse(r, (parentObject's (menu item f)'s (menu f)))		end if	end tellend menu_click_recurse